/*!
 * Dragonfly - Error Composition Manager
 * Copyright(c) 2012 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */

/*!
 * Main Export
 */

module.exports = function (name) {
  var dragonfly = new Dragonfly(name);
  return dragonfly;
};

/*!
 * Module Version
 */

module.exports.version = '0.2.1';

/**
 * ## Dragonfly
 *
 * The Dragonfly constructor creates a repository
 * for errors to be registered to and created from.
 *
 * @param {String} Error constructor name
 * @name Dragonfly
 * @api public
 */

function Dragonfly (name) {
  name = name || 'Dragonfly';
  this._proto = constructError(name);
  this._specs = {};
}

/**
 * ### .register (key, spec)
 *
 * Register an error key and the default values to include
 * on the error prototype. It is recommended that `message`
 * and `code` are defined. Do not use `name` or `stack`.
 *
 *     errors.register('error.1', {
 *         message: 'This is the first error.'
 *       , code: 'EERROR1'
 *     });
 *
 * The key will not be included in any form on the constructed
 * error when constructed.
 *
 * @param {String} key
 * @param {Object} specifications
 * @name register
 * @api public
 */

Dragonfly.prototype.register = function (key, spec) {
  spec = spec || {};
  this._specs[key] = spec;
};

/**
 * ### .create (key[, args, ... ])
 *
 * Construct a new error and return it. The start stack
 * function will be the the location of the creation. Any
 * parameters included in addition to the key will be included
 * in an arguments array as a property of the constructed error.
 *
 *     throw errors.create('error.1', {
 *       user: '1234'
 *     });
 *
 * @param {String} key
 * @param {Mixed} arguments
 * @returns {Error} constructed
 * @name create
 * @api public
 */

Dragonfly.prototype.create = function ()  {
  var key = arguments[0]
    , args = Array.prototype.slice.call(arguments, 1)
    , proto = this._specs[key]
    , ssf = arguments.callee;

  // graceful non-key handle
  if (!proto) {
    throw new Error('Invalid error creation: ' + key);
  }

  proto.arguments = args;
  return new this._proto(proto, ssf);
};

/*!
 * constructError (name)
 *
 * Dynamically build an Error constructor to be used within the
 * current namespace. The name will be properly bound to
 * the prototype of the error as `name`. Also attach the
 * `toJSON` method.
 *
 * @param {String} error name
 * @returns Error Constructor
 * @name constructError
 * @api private
 */

function constructError (name) {

  // constructor
  function ErrorProto (opts, ssf) {
    opts = opts || {};
    merge(this, opts);
    Error.captureStackTrace(this, ssf || arguments.callee);
  }

  // extensions
  ErrorProto.prototype = Object.create(Error.prototype);
  ErrorProto.prototype.name = name;
  ErrorProto.prototype.constructor = ErrorProto;

  // toJSON helper
  ErrorProto.prototype.toJSON = function () {
    return merge({
        name: this.name
      , stack: this.stack
    }, this);
  };

  // return constructor
  return ErrorProto;
}

/*!
 * merge (target, source)
 *
 * Merge the proto with the specifications. Only include set
 * values, not getters/setters.
 *
 * @param {Object} target
 * @param {Object} source
 * @return modified target
 * @name merge
 * @api private
 */

function merge (a, b) {
  for (var key in b) {
    if (!b.hasOwnProperty(key)) continue;
    a[key] = b[key];
  }
  return a;
}
